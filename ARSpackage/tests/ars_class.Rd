\name{ars}
\alias{ars}
\title{The adapt_reject function}
\usage{
  ars(n_samples, fx, bounds = c(-Inf, Inf),
    guess_of_mode = 0, ...)
}
\arguments{
  \item{n_samples:}{Number of samples desired from
  distribution}

  \item{fx:}{Function to sample from}

  \item{bounds:}{Bounds of function of interest.  The
  default is an unbounded function}
}
\value{
  a vector containing \code{n} points sampled from the f(x)
  distribution
}
\description{
  This calls the class Cadapt_reject_sample and its
  methods.  It returns a vector of samples generated via
  the Adaptive rejective sampling method.
}


\name{Cadapt_reject_sample}
\title{The adapt_reject class}
\description{
  This class contains all the methods used to perform an AR
  sampling.

  A method to intialize the ARS class for sampling.  Will
  store values input from user and will also initialize
  empty arrays for all other slots.

  The main objective of this validity check is to ensure at
  creation that the number of samples desired is a positive
  integer

  Cadapt_reject_sample method for generating first two
  points.  If the distribution is unbounded, then find the
  function's mode and pick points surrounding it.  If it's
  bounded on one side, we use the bound given and search
  until we find a point that corresponds to the opposite
  end of the domain with respect to their derivatives.  If
  bounded on both sides, use given bounds.

  Cadapt_reject_sample method that evaluates the log(f(x))
  for a given x and the derivative as well.

  Cadapt_reject_sample method to normalize the upper bounds
  of log(f(x)).  Multiple objective are performed here. The
  most important being the calculation of the abcissa
  vector Z.  Additionally, the weights and exact values of
  the piecewise integration of each interval and the
  normalization factor for the entire upper bound are
  calculated and the x's, their evaluations and their
  derivatives are sorted by x.

  Method to sample from s_x.  The basic algorithm is as
  follows: 1. Determine an interval to sample from using
  the weights of integration of the function on each
  interval, computed in the s_x method. 2.  Use inverse CDF
  method to sample from within the selected interval.
  Return the object with new sample.

  Cadapt_reject_sample method to evaluate the upper bound
  of x_star.

  Cadapt_reject_sample method to evaluate the lower bound
  of x_star.

  Cadapt_reject_sample method to determine which ACC/REJ
  criteria a given sampled value fits into and updates the
  samples and x values accordingly.
}
\section{Slots}{
  \describe{ \item{\code{n}:}{Variable of class
  \code{"numeric"}, n, containing the number of points to
  sample, taken as user input.} \item{\code{f_x}:}{Function
  of class \code{"function"}, containing the f(x) to sample
  from, taken as user input.}
  \item{\code{bounds}:}{Variable of class \code{"numeric"},
  n, containing the bounds of the function, taken as user
  input.} \item{\code{output}:}{Variable of class
  \code{"vector"}, containing sampled points to return to
  user.} \item{\code{h_at_x}:}{Variable of class
  \code{"vector"}, containing computed log(f(x)) values at
  all x values} \item{\code{hprime_at_x}:}{Variable of
  class \code{"vector"}, containing computed derivative of
  log(f(x)) values at all x values}
  \item{\code{z}:}{Variable of class \code{"vector"},
  containing abscissae of upper bound function.}
  \item{\code{samples}:}{Variable of class \code{"vector"},
  containing random numbers generated by s(x) and unif.}
  \item{\code{x}:}{Variable of class \code{"vector"},
  containing x values used in ARS.}
  \item{\code{weights}:}{Variable of class \code{"vector"},
  containing sampled points to return to user.}
  \item{\code{output}:}{Variable of class \code{"numeric"},
  containing sampled points to return to user.}
  \item{\code{mat_sorted}:}{Variable of class
  \code{"matrix"}, containing x values, their corresponding
  h and h prime values, sorted by increasing x.}
  \item{\code{guess_of_mode}:}{Variable of class
  \code{"numeric"}, containing an optional user input guess
  of the mode of the distribution, should be within 200 of
  actual mode.} }
}

\name{ev_h}
\title{ars: The adapt_reject function}
\usage{
  ars(n_samples, fx, bounds = c(-Inf, Inf),
    guess_of_mode = 0, ...)
}
\arguments{
  \item{n_samples:}{Number of samples desired from
  distribution}

  \item{fx:}{Function to sample from}

  \item{bounds:}{Bounds of function of interest.  The
  default is an unbounded function}
}
\value{
  a vector containing \code{n} points sampled from the f(x)
  distribution
}
\description{
  This calls the class Cadapt_reject_sample and its
  methods.  It returns a vector of samples generated via
  the Adaptive rejective sampling method.
}

\name{gen_x}
\title{Generation of initial x points}
\usage{
  gen_x(Cadapt_reject_sample)
}
\arguments{
  \item{Cadapt_reject_sample:}{object of the ARS class}
}
\description{
  Cadapt_reject_sample method for generating first two points.  
  If the distribution is unbounded, then find the function's 
  mode and pick points surrounding it.  If it's bounded on 
  one side, we use the bound given and search until we find a 
  point that corresponds to the opposite end of the domain with 
  respect to their derivatives.  If bounded on both sides, use 
  given bounds.
}

\name{initialize}
\title{Initialize new Cadapt_reject_sample object}
\usage{
  new( "Cadapt_reject_sample", n, f_x, bounds, guess_of_mode, ... )
}
\arguments{
    \item{n:}{number of desired samples}
    \item{f_x:}{function on which to sample
    \item{bounds:}{bounds of density}
    \item{guess_of_mode:}{guess of where mode is located}
}
\description{
    Initialization of new Cadapt_reject_sample object.
}

\name{lower}
\title{ARS lower method}
\usage{
  lower(Cadapt_reject_sample)
}
\arguments{
  \item{Cadapt_reject_sample:}{object of the ARS class}
}
\description{
  Cadapt_reject_sample method to evaluate the lower 
  bound of x_star.
}

\name{s_x}
\title{ARS s_x method}
\usage{
  s_x(Cadapt_reject_sample)
}
\arguments{
  \item{Cadapt_reject_sample:}{object of the ARS class}
}
\description{
  Cadapt_reject_sample method to normalize the upper bounds of
  log(f(x)).  Multiple objective are performed here. The most 
  important being the calculation of the abcissa vector Z.  
  Additionally, the weights and exact values of the piecewise 
  integration of each interval and the normalization factor for 
  the entire upper bound are calculated and the x's, their 
  evaluations and their derivatives are sorted by x. 
}

\name{sampling}
\title{ARS sampling method}
\usage{
  sampling(Cadapt_reject_sample)
}
\arguments{
  \item{Cadapt_reject_sample:}{object of the ARS class}
}
\description{
  Method to sample from s_x.  The basic algorithm is as 
  follows: 1. Determine an interval to sample from using 
  the weights of integration of the function on each 
  interval, computed in the s_x method. 2.  Use inverse 
  CDF method to sample from within the selected interval.  
  Return the object with new sample.
}


\name{update}
\title{ARS update method}
\usage{
  update(Cadapt_reject_sample)
}
\arguments{
  \item{Cadapt_reject_sample:}{object of the ARS class}
}
\description{
  Cadapt_reject_sample method to determine which ACC/REJ 
  criteria a given sampled value fits into and updates 
  the samples and x values accordingly.  
}

\name{upper}
\title{ars: The adapt_reject function}
\usage{
  upper(Cadapt_reject_sample)
}
\arguments{
  \item{Cadapt_reject_sample:}{object of the ARS class}
}
\description{
  Cadapt_reject_sample method to evaluate the upper bound 
  of x_star.
}
